import * as p from '@clack/prompts';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { resolve, basename } from 'node:path';
import { execSync } from 'node:child_process';

const ENV_PATH = resolve(process.cwd(), '.env');

function color(text: string, code: number): string {
  return `\x1b[${code}m${text}\x1b[0m`;
}
const dim = (t: string) => color(t, 2);
const cyan = (t: string) => color(t, 36);
const green = (t: string) => color(t, 32);
const yellow = (t: string) => color(t, 33);
const bold = (t: string) => color(t, 1);

function cancelled(): never {
  p.cancel('Setup cancelled.');
  process.exit(0);
}

function loadExistingEnv(): Record<string, string> {
  if (!existsSync(ENV_PATH)) return {};
  const env: Record<string, string> = {};
  for (const line of readFileSync(ENV_PATH, 'utf-8').split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eq = trimmed.indexOf('=');
    if (eq === -1) continue;
    env[trimmed.slice(0, eq)] = trimmed.slice(eq + 1);
  }
  return env;
}

function writeEnvFile(env: Record<string, string>): void {
  const lines: string[] = [
    '# agentcord configuration',
    '# Generated by: npm run setup',
    '',
  ];

  const sections: Array<{ comment: string; keys: string[] }> = [
    { comment: '# Discord App', keys: ['DISCORD_TOKEN', 'DISCORD_CLIENT_ID', 'DISCORD_GUILD_ID'] },
    { comment: '# Security', keys: ['ALLOWED_USERS', 'ALLOW_ALL_USERS'] },
    { comment: '# Paths', keys: ['ALLOWED_PATHS', 'DEFAULT_DIRECTORY'] },
    { comment: '# Codex Defaults', keys: ['CODEX_SANDBOX_MODE', 'CODEX_APPROVAL_POLICY', 'CODEX_NETWORK_ACCESS_ENABLED'] },
    { comment: '# Optional', keys: ['MESSAGE_RETENTION_DAYS', 'RATE_LIMIT_MS'] },
  ];

  for (const section of sections) {
    const sectionEntries = section.keys.filter(k => env[k]);
    if (sectionEntries.length === 0) continue;
    lines.push(section.comment);
    for (const key of sectionEntries) {
      lines.push(`${key}=${env[key]}`);
    }
    lines.push('');
  }

  writeFileSync(ENV_PATH, lines.join('\n'));
}

function getDiscordUserId(): string | null {
  try {
    // Try to get from existing .env
    const env = loadExistingEnv();
    if (env.ALLOWED_USERS) return env.ALLOWED_USERS.split(',')[0].trim();
  } catch { /* ignore */ }
  return null;
}

export async function runSetup(): Promise<void> {
  const existing = loadExistingEnv();
  const isReconfigure = Object.keys(existing).length > 0;

  p.intro(bold(' agentcord setup '));

  if (isReconfigure) {
    p.note(
      'Existing .env file detected.\nYour current values will be shown as defaults.',
      'Reconfiguring',
    );
  }

  // ─── Step 1: Discord App Creation Guide ───

  const hasApp = await p.confirm({
    message: 'Do you already have a Discord Application created?',
    initialValue: !!existing.DISCORD_TOKEN,
  });
  if (p.isCancel(hasApp)) cancelled();

  if (!hasApp) {
    p.note(
      [
        `${bold('1.')} Go to ${cyan('https://discord.com/developers/applications')}`,
        `${bold('2.')} Click ${green('"New Application"')} and give it a name`,
        `${bold('3.')} Go to the ${bold('Bot')} tab on the left`,
        `${bold('4.')} Click ${green('"Reset Token"')} and copy the token`,
        `${bold('5.')} Under ${bold('Privileged Gateway Intents')}, enable:`,
        `   ${yellow('*')} Message Content Intent`,
        `   ${yellow('*')} Server Members Intent`,
        `${bold('6.')} Go to the ${bold('General Information')} tab`,
        `${bold('7.')} Copy the ${bold('Application ID')} (this is your Client ID)`,
        '',
        dim('Keep this tab open — you\'ll need the token and ID next.'),
      ].join('\n'),
      'Create a Discord App',
    );

    await p.confirm({
      message: 'Ready to continue?',
      initialValue: true,
    });
  }

  // ─── Step 2: Bot Token ───

  const token = await p.password({
    message: 'Paste your Discord Bot Token:',
    validate(value) {
      if (!value || !value.trim()) return 'Token is required';
      if (value.length < 50) return 'That doesn\'t look like a valid bot token';
    },
  });
  if (p.isCancel(token)) cancelled();

  // ─── Step 3: Client ID ───

  const clientId = await p.text({
    message: 'Paste your Application (Client) ID:',
    placeholder: existing.DISCORD_CLIENT_ID || '123456789012345678',
    initialValue: existing.DISCORD_CLIENT_ID,
    validate(value) {
      if (!value || !value.trim()) return 'Client ID is required';
      if (!/^\d{17,20}$/.test(value.trim())) return 'Client ID should be a 17-20 digit number';
    },
  });
  if (p.isCancel(clientId)) cancelled();

  // ─── Step 4: Guild ID ───

  const guildSetup = await p.confirm({
    message: 'Do you want to register commands to a specific server? (instant, recommended for testing)',
    initialValue: !!existing.DISCORD_GUILD_ID,
  });
  if (p.isCancel(guildSetup)) cancelled();

  let guildId = '';
  if (guildSetup) {
    if (!hasApp) {
      p.note(
        [
          `${bold('1.')} Open Discord and go to ${bold('User Settings > Advanced')}`,
          `${bold('2.')} Enable ${green('"Developer Mode"')}`,
          `${bold('3.')} Right-click your server name and click ${green('"Copy Server ID"')}`,
        ].join('\n'),
        'How to get your Server ID',
      );
    }

    const guildInput = await p.text({
      message: 'Paste your Server (Guild) ID:',
      placeholder: existing.DISCORD_GUILD_ID || '123456789012345678',
      initialValue: existing.DISCORD_GUILD_ID,
      validate(value) {
        if (!value || !value.trim()) return 'Guild ID is required';
        if (!/^\d{17,20}$/.test(value.trim())) return 'Guild ID should be a 17-20 digit number';
      },
    });
    if (p.isCancel(guildInput)) cancelled();
    guildId = guildInput.trim();
  }

  // ─── Step 5: Allowed Users ───

  const authMode = await p.select({
    message: 'Who should be allowed to use the bot?',
    options: [
      {
        value: 'whitelist',
        label: 'Specific users (recommended)',
        hint: 'comma-separated Discord user IDs',
      },
      {
        value: 'all',
        label: 'Everyone in the server',
        hint: 'not recommended for shared servers',
      },
    ],
    initialValue: existing.ALLOW_ALL_USERS === 'true' ? 'all' : 'whitelist',
  });
  if (p.isCancel(authMode)) cancelled();

  let allowedUsers = '';
  if (authMode === 'whitelist') {
    const existingUser = getDiscordUserId();

    if (!hasApp && !existingUser) {
      p.note(
        [
          `${bold('1.')} Open Discord with ${bold('Developer Mode')} enabled`,
          `${bold('2.')} Click on your profile picture or username`,
          `${bold('3.')} Click ${green('"Copy User ID"')}`,
          '',
          dim('You can add more users later by editing .env'),
        ].join('\n'),
        'How to get your User ID',
      );
    }

    const usersInput = await p.text({
      message: 'Enter allowed Discord User IDs (comma-separated):',
      placeholder: '123456789012345678',
      initialValue: existing.ALLOWED_USERS,
      validate(value) {
        if (!value || !value.trim()) return 'At least one user ID is required';
        const ids = value.split(',').map(s => s.trim());
        for (const id of ids) {
          if (!/^\d{17,20}$/.test(id)) return `Invalid user ID: ${id}`;
        }
      },
    });
    if (p.isCancel(usersInput)) cancelled();
    allowedUsers = usersInput.trim();
  }

  // ─── Step 6: Paths ───

  const homeDir = process.env.HOME || process.env.USERPROFILE || '/';

  const defaultDir = await p.text({
    message: 'Default working directory for new sessions:',
    placeholder: homeDir,
    initialValue: existing.DEFAULT_DIRECTORY || homeDir,
    validate(value) {
      if (!value) return 'Directory is required';
      const resolved = resolve(value.trim().replace(/^~/, homeDir));
      if (!existsSync(resolved)) return `Directory does not exist: ${resolved}`;
    },
  });
  if (p.isCancel(defaultDir)) cancelled();
  const resolvedDefault = resolve(defaultDir.trim().replace(/^~/, homeDir));

  const restrictPaths = await p.confirm({
    message: 'Restrict which directories the bot can access?',
    initialValue: !!existing.ALLOWED_PATHS,
  });
  if (p.isCancel(restrictPaths)) cancelled();

  let allowedPaths = '';
  if (restrictPaths) {
    const pathsInput = await p.text({
      message: 'Allowed directories (comma-separated):',
      placeholder: `${homeDir}/Dev,${homeDir}/Projects`,
      initialValue: existing.ALLOWED_PATHS || resolvedDefault,
      validate(value) {
        if (!value || !value.trim()) return 'At least one path is required';
      },
    });
    if (p.isCancel(pathsInput)) cancelled();
    allowedPaths = pathsInput.trim();
  }

  // ─── Step 7: Write .env ───

  const env: Record<string, string> = {
    DISCORD_TOKEN: token.trim(),
    DISCORD_CLIENT_ID: clientId.trim(),
  };
  if (guildId) env.DISCORD_GUILD_ID = guildId;
  if (authMode === 'all') {
    env.ALLOW_ALL_USERS = 'true';
  } else {
    env.ALLOWED_USERS = allowedUsers;
  }
  env.DEFAULT_DIRECTORY = resolvedDefault;
  if (allowedPaths) env.ALLOWED_PATHS = allowedPaths;

  // Preserve optional settings from existing config
  if (existing.MESSAGE_RETENTION_DAYS) env.MESSAGE_RETENTION_DAYS = existing.MESSAGE_RETENTION_DAYS;
  if (existing.RATE_LIMIT_MS) env.RATE_LIMIT_MS = existing.RATE_LIMIT_MS;
  if (existing.CODEX_SANDBOX_MODE) env.CODEX_SANDBOX_MODE = existing.CODEX_SANDBOX_MODE;
  if (existing.CODEX_APPROVAL_POLICY) env.CODEX_APPROVAL_POLICY = existing.CODEX_APPROVAL_POLICY;
  if (existing.CODEX_NETWORK_ACCESS_ENABLED) env.CODEX_NETWORK_ACCESS_ENABLED = existing.CODEX_NETWORK_ACCESS_ENABLED;

  const s = p.spinner();
  s.start('Writing .env file');
  writeEnvFile(env);
  s.stop('Configuration saved to .env');

  // ─── Step 8: Generate Invite URL ───

  const permissions = 8; // Administrator (simplest for category/channel management)
  const scopes = 'bot%20applications.commands';
  const inviteUrl = `https://discord.com/oauth2/authorize?client_id=${clientId.trim()}&permissions=${permissions}&scope=${scopes}`;

  p.note(
    [
      bold('Add the bot to your server:'),
      '',
      cyan(inviteUrl),
      '',
      dim('Open this URL in your browser and select your server.'),
    ].join('\n'),
    'Invite Link',
  );

  const openBrowser = await p.confirm({
    message: 'Open the invite URL in your browser?',
    initialValue: true,
  });
  if (p.isCancel(openBrowser)) cancelled();

  if (openBrowser) {
    try {
      const cmd = process.platform === 'darwin' ? 'open' : process.platform === 'win32' ? 'start' : 'xdg-open';
      execSync(`${cmd} "${inviteUrl}"`, { stdio: 'ignore' });
    } catch {
      p.log.warn('Could not open browser. Please open the URL manually.');
    }
  }

  // ─── Step 9: Verify Connection ───

  const verify = await p.confirm({
    message: 'Test the bot connection now?',
    initialValue: true,
  });
  if (p.isCancel(verify)) cancelled();

  if (verify) {
    s.start('Connecting to Discord...');
    try {
      // Dynamic import to avoid loading discord.js at module level
      const { Client, GatewayIntentBits } = await import('discord.js');
      const client = new Client({
        intents: [GatewayIntentBits.Guilds],
      });

      const loginResult = await Promise.race([
        new Promise<string>((res, rej) => {
          client.once('ready', () => {
            const name = client.user?.tag || 'Unknown';
            const guildCount = client.guilds.cache.size;
            client.destroy();
            res(`${name} — connected to ${guildCount} server(s)`);
          });
          client.login(token.trim()).catch(rej);
        }),
        new Promise<never>((_, rej) =>
          setTimeout(() => rej(new Error('Connection timed out after 15s')), 15000),
        ),
      ]);

      s.stop(green(`Connected: ${loginResult}`));
    } catch (err: unknown) {
      s.stop(`Connection failed: ${(err as Error).message}`);
      p.log.warn('Double-check your bot token and try again.');
      p.log.info(`You can re-run setup with: ${cyan('npm run setup')}`);
    }
  }

  // ─── Step 10: Optional Providers ───

  const installCodex = await p.confirm({
    message: 'Install OpenAI Codex support? (requires @openai/codex-sdk)',
    initialValue: false,
  });
  if (p.isCancel(installCodex)) cancelled();

  if (installCodex) {
    s.start('Installing @openai/codex-sdk...');
    try {
      execSync('npm install @openai/codex-sdk', { cwd: process.cwd(), stdio: 'pipe' });
      s.stop(green('Codex SDK installed'));
    } catch (err: unknown) {
      s.stop(`Failed to install Codex SDK: ${(err as Error).message}`);
      p.log.warn(`You can install it manually: ${cyan('npm install @openai/codex-sdk')}`);
    }
  }

  // ─── Step 11: Install Daemon ───

  const installDaemon = await p.confirm({
    message: 'Start agentcord as a background service? (auto-starts on boot, restarts on crash)',
    initialValue: true,
  });
  if (p.isCancel(installDaemon)) cancelled();

  if (installDaemon) {
    s.start('Installing background service...');
    try {
      const { handleDaemon } = await import('./daemon.ts');
      // Suppress clack output during daemon install — it logs its own messages
      await handleDaemon('install');
      s.stop(green('Background service installed and running'));
    } catch (err: unknown) {
      s.stop(`Service install failed: ${(err as Error).message}`);
      p.log.warn(`You can install it later with: ${cyan('agentcord daemon install')}`);
    }
  }

  // ─── Done ───

  const nextSteps = [
    `Use ${bold('/session new <name>')} in Discord to create your first session.`,
  ];

  if (!installDaemon) {
    nextSteps.unshift(
      `Start the bot:  ${cyan('agentcord')}`,
      '',
    );
  } else {
    nextSteps.unshift(
      `The bot is running in the background.`,
      `Check status:   ${cyan('agentcord daemon status')}`,
      `View logs:      ${cyan(`tail -f agentcord.log`)}`,
      '',
    );
  }

  nextSteps.push('', `Re-run setup:   ${cyan('agentcord setup')}`);

  p.note(nextSteps.join('\n'), 'Next Steps');

  p.outro(green('Setup complete!'));
}
